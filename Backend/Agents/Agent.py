from openai import OpenAI
from pydantic import BaseModel, Field
import os
from typing import Literal, List
from dotenv import load_dotenv
from Backend.db import engine, Session
from Backend.Agents.WeddingAgent.WeddingMemory import MemoryMangement
from memory import add_message, get_conversation_messages
import json
load_dotenv()


# class FactResponse(BaseModel):
#     fact_summary: str
#     response: str
#     category: Literal["fact","duplicate", "update", "other"]
#     memory: List[str] = Field(..., description="A list of relevant memories or pieces of information associated with the fact including the memory id.")
#     reason: str
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
tools = [
    {
        "type": "function",
        "name": "get_horoscope",
        "description": "Get today's horoscope for an astrological sign.",
        "parameters": {
            "type": "object",
            "properties": {
                "sign": {
                    "type": "string",
                    "description": "An astrological sign like Taurus or Aquarius",
                },
            },
            "required": ["sign"],
        },
    },
]

  
class Agent:
    def __init__(self, model):
        self.openai_key = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
        self.model = model
        
        
    def generate_response(self, inputs):
        response = self.openai_key.responses.parse(
            model=self.model,
            input=inputs,
            tools=tools,
            # text_format=FactResponse,
            store=False,
        )

        llm_response = response.output
        return response

def get_horoscope(sign):
    return f"{sign}: Next Tuesday you will befriend a baby otter."
    
if __name__ == '__main__':
    _agent = Agent("gpt-4")
    inputs = [{
                "role": "system",
                "content": "You're a helpful assistant"
            },
            {
              "role": "user",
              "content": "What is my horoscope? I am an Aquarius."    
              
              }]
    res = _agent.generate_response(inputs=inputs)
    
    # Save function call outputs for subsequent requests
    function_call = None
    function_call_arguments = None
    inputs += res.output
    for item in res.output:
        if item.type == "function_call":
            function_call = item
            function_call_arguments = json.loads(item.arguments)

    # 3. Execute the function logic for get_horoscope
    result = {"horoscope": get_horoscope(function_call_arguments["sign"])}

    # 4. Provide function call results to the model
    inputs.append({
        "type": "function_call_output",
        "call_id": function_call.call_id,
        "output": json.dumps(result),
    })

    print("Final input:")
    print(inputs)

    response = client.responses.create(
        model="gpt-4",
        instructions="Respond only with a horoscope generated by a tool.",
        tools=tools,
        input=inputs,
    )

    # 5. The model should be able to give a response!
    print("Final output:")
    print(response.model_dump_json(indent=2))
    print("\n" + response.output_text)
    


